import { EventEmitter } from "events";
import { VoiceConnection, AudioPlayer as DiscordAudioPlayer } from "@discordjs/voice";
import { VoiceChannel } from "discord.js";
import { Track, PlayerOptions, PlayerEvents, SourcePlugin, SearchResult, ProgressBarOptions, LoopMode } from "../types";
import { Queue } from "./Queue";
import { PluginManager } from "../plugins";
import type { PlayerManager } from "./PlayerManager";
export declare interface Player {
    on<K extends keyof PlayerEvents>(event: K, listener: (...args: PlayerEvents[K]) => void): this;
    emit<K extends keyof PlayerEvents>(event: K, ...args: PlayerEvents[K]): boolean;
}
export declare class Player extends EventEmitter {
    readonly guildId: string;
    connection: VoiceConnection | null;
    audioPlayer: DiscordAudioPlayer;
    queue: Queue;
    volume: number;
    isPlaying: boolean;
    isPaused: boolean;
    options: PlayerOptions;
    pluginManager: PluginManager;
    userdata?: Record<string, any>;
    private manager;
    private leaveTimeout;
    private currentResource;
    private volumeInterval;
    private skipLoop;
    private ttsPlayer;
    private ttsQueue;
    private ttsActive;
    private withTimeout;
    private debug;
    constructor(guildId: string, options: PlayerOptions | undefined, manager: PlayerManager);
    private setupEventListeners;
    private ensureTTSPlayer;
    addPlugin(plugin: SourcePlugin): void;
    removePlugin(name: string): boolean;
    connect(channel: VoiceChannel): Promise<VoiceConnection>;
    search(query: string, requestedBy: string): Promise<SearchResult>;
    play(query: string | Track, requestedBy?: string): Promise<boolean>;
    /**
     * Interrupt current music with a TTS track. Pauses music, swaps the
     * subscription to a dedicated TTS player, plays TTS, then resumes.
     */
    interruptWithTTSTrack(track: Track): Promise<void>;
    /** Play queued TTS items sequentially */
    private playNextTTS;
    /** Build AudioResource for a given track using the plugin pipeline */
    private resourceFromTrack;
    private generateWillNext;
    private playNext;
    pause(): boolean;
    resume(): boolean;
    stop(): boolean;
    skip(): boolean;
    loop(mode?: LoopMode): LoopMode;
    autoPlay(mode?: boolean): boolean;
    setVolume(volume: number): boolean;
    shuffle(): void;
    clearQueue(): void;
    /**
     * Insert a track or list of tracks into the upcoming queue at a specific position (0 = play after current).
     * - If `query` is a string, performs a search and inserts resulting tracks (playlist supported).
     * - If a Track or Track[] is provided, inserts directly.
     * Does not auto-start playback; it only modifies the queue.
     */
    insert(query: string | Track | Track[], index: number, requestedBy?: string): Promise<boolean>;
    remove(index: number): Track | null;
    getProgressBar(options?: ProgressBarOptions): string;
    private formatTime;
    private scheduleLeave;
    destroy(): void;
    get queueSize(): number;
    get currentTrack(): Track | null;
    get upcomingTracks(): Track[];
    get previousTracks(): Track[];
    get availablePlugins(): string[];
}
//# sourceMappingURL=Player.d.ts.map