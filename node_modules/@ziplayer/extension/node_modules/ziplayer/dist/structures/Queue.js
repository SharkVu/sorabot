"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Queue = void 0;
class Queue {
    constructor() {
        this.tracks = [];
        this.current = null;
        this.history = [];
        this._autoPlay = false;
        this._loop = "off";
        this.willnext = null;
    }
    add(track) {
        this.tracks.push(track);
    }
    addMultiple(tracks) {
        this.tracks.push(...tracks);
    }
    /** Insert a track at a specific upcoming position (0 = next) */
    insert(track, index) {
        if (!Number.isFinite(index)) {
            this.tracks.push(track);
            return;
        }
        const i = Math.max(0, Math.min(Math.floor(index), this.tracks.length));
        if (i === this.tracks.length) {
            this.tracks.push(track);
            return;
        }
        if (i <= 0) {
            this.tracks.unshift(track);
            return;
        }
        this.tracks.splice(i, 0, track);
    }
    /** Insert multiple tracks at a specific upcoming position, preserving order */
    insertMultiple(tracks, index) {
        if (!Array.isArray(tracks) || tracks.length === 0)
            return;
        if (!Number.isFinite(index)) {
            this.tracks.push(...tracks);
            return;
        }
        const i = Math.max(0, Math.min(Math.floor(index), this.tracks.length));
        if (i === 0) {
            this.tracks = [...tracks, ...this.tracks];
            return;
        }
        if (i === this.tracks.length) {
            this.tracks.push(...tracks);
            return;
        }
        this.tracks.splice(i, 0, ...tracks);
    }
    remove(index) {
        if (index < 0 || index >= this.tracks.length)
            return null;
        return this.tracks.splice(index, 1)[0];
    }
    next(ignoreLoop = false) {
        if (this.current) {
            if (this._loop === "track" && !ignoreLoop) {
                return this.current;
            }
            this.history.push(this.current);
            if (this.history.length > 200) {
                this.history.shift();
            }
        }
        this.current = this.tracks.shift() || null;
        if (!this.current && this._loop === "queue" && this.history.length > 0 && !ignoreLoop) {
            this.tracks = [...this.history];
            this.history = [];
            this.current = this.tracks.shift() || null;
        }
        return this.current;
    }
    clear() {
        this.tracks = [];
    }
    autoPlay(value) {
        if (typeof value !== "undefined") {
            this._autoPlay = value;
        }
        return this._autoPlay;
    }
    loop(mode) {
        if (mode) {
            this._loop = mode;
        }
        return this._loop;
    }
    shuffle() {
        for (let i = this.tracks.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [this.tracks[i], this.tracks[j]] = [this.tracks[j], this.tracks[i]];
        }
    }
    get size() {
        return this.tracks.length;
    }
    get isEmpty() {
        return this.tracks.length === 0;
    }
    get currentTrack() {
        return this.current;
    }
    get previousTracks() {
        return [...this.history];
    }
    get nextTrack() {
        return this.tracks[0] || null;
    }
    willNextTrack(track) {
        if (track) {
            this.willnext = track;
            return this.willnext;
        }
        return this.willnext;
    }
    getTracks() {
        return [...this.tracks];
    }
    getTrack(index) {
        return this.tracks[index] || null;
    }
}
exports.Queue = Queue;
//# sourceMappingURL=Queue.js.map