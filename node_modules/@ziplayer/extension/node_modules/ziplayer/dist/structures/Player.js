"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Player = void 0;
const events_1 = require("events");
const voice_1 = require("@discordjs/voice");
const Queue_1 = require("./Queue");
const plugins_1 = require("../plugins");
class Player extends events_1.EventEmitter {
    withTimeout(promise, message) {
        const timeout = this.options.extractorTimeout ?? 15000;
        return Promise.race([promise, new Promise((_, reject) => setTimeout(() => reject(new Error(message)), timeout))]);
    }
    debug(message, ...optionalParams) {
        if (this.listenerCount("debug") > 0) {
            this.emit("debug", message, ...optionalParams);
        }
    }
    constructor(guildId, options = {}, manager) {
        super();
        this.connection = null;
        this.volume = 100;
        this.isPlaying = false;
        this.isPaused = false;
        this.leaveTimeout = null;
        this.currentResource = null;
        this.volumeInterval = null;
        this.skipLoop = false;
        // TTS support
        this.ttsPlayer = null;
        this.ttsQueue = [];
        this.ttsActive = false;
        this.debug(`[Player] Constructor called for guildId: ${guildId}`);
        this.guildId = guildId;
        this.queue = new Queue_1.Queue();
        this.manager = manager;
        this.audioPlayer = (0, voice_1.createAudioPlayer)({
            behaviors: {
                noSubscriber: voice_1.NoSubscriberBehavior.Pause,
                maxMissedFrames: 100,
            },
        });
        this.pluginManager = new plugins_1.PluginManager();
        this.options = {
            leaveOnEnd: true,
            leaveOnEmpty: true,
            leaveTimeout: 100000,
            volume: 100,
            quality: "high",
            extractorTimeout: 50000,
            selfDeaf: true,
            selfMute: false,
            ...options,
            tts: {
                createPlayer: false,
                interrupt: true,
                volume: 100,
                Max_Time_TTS: 60000,
                ...(options?.tts || {}),
            },
        };
        this.volume = this.options.volume || 100;
        this.userdata = this.options.userdata;
        this.setupEventListeners();
        // Optionally pre-create the TTS AudioPlayer
        if (this.options?.tts?.createPlayer) {
            this.ensureTTSPlayer();
        }
    }
    setupEventListeners() {
        this.audioPlayer.on("stateChange", (oldState, newState) => {
            this.debug(`[Player] AudioPlayer stateChange from ${oldState.status} to ${newState.status}`);
            if (newState.status === voice_1.AudioPlayerStatus.Idle && oldState.status !== voice_1.AudioPlayerStatus.Idle) {
                // Track ended
                const track = this.queue.currentTrack;
                if (track) {
                    this.debug(`[Player] Track ended: ${track.title}`);
                    this.emit("trackEnd", track);
                }
                this.playNext();
            }
            else if (newState.status === voice_1.AudioPlayerStatus.Playing &&
                (oldState.status === voice_1.AudioPlayerStatus.Idle || oldState.status === voice_1.AudioPlayerStatus.Buffering)) {
                // Track started
                this.isPlaying = true;
                this.isPaused = false;
                const track = this.queue.currentTrack;
                if (track) {
                    this.debug(`[Player] Track started: ${track.title}`);
                    this.emit("trackStart", track);
                }
            }
            else if (newState.status === voice_1.AudioPlayerStatus.Paused && oldState.status !== voice_1.AudioPlayerStatus.Paused) {
                // Track paused
                this.isPaused = true;
                const track = this.queue.currentTrack;
                if (track) {
                    this.debug(`[Player] Player paused on track: ${track.title}`);
                    this.emit("playerPause", track);
                }
            }
            else if (newState.status !== voice_1.AudioPlayerStatus.Paused && oldState.status === voice_1.AudioPlayerStatus.Paused) {
                // Track resumed
                this.isPaused = false;
                const track = this.queue.currentTrack;
                if (track) {
                    this.debug(`[Player] Player resumed on track: ${track.title}`);
                    this.emit("playerResume", track);
                }
            }
            else if (newState.status === voice_1.AudioPlayerStatus.AutoPaused) {
                this.debug(`[Player] AudioPlayerStatus.AutoPaused`);
            }
            else if (newState.status === voice_1.AudioPlayerStatus.Buffering) {
                this.debug(`[Player] AudioPlayerStatus.Buffering`);
            }
        });
        this.audioPlayer.on("error", (error) => {
            this.debug(`[Player] AudioPlayer error:`, error);
            this.emit("playerError", error, this.queue.currentTrack || undefined);
            this.playNext();
        });
        this.audioPlayer.on("debug", (...args) => {
            if (this.manager.debugEnabled) {
                this.emit("debug", ...args);
            }
        });
    }
    ensureTTSPlayer() {
        if (this.ttsPlayer)
            return this.ttsPlayer;
        this.ttsPlayer = (0, voice_1.createAudioPlayer)({
            behaviors: {
                noSubscriber: voice_1.NoSubscriberBehavior.Pause,
                maxMissedFrames: 100,
            },
        });
        this.ttsPlayer.on("error", (e) => this.debug("[TTS] error:", e));
        return this.ttsPlayer;
    }
    addPlugin(plugin) {
        this.debug(`[Player] Adding plugin: ${plugin.name}`);
        this.pluginManager.register(plugin);
    }
    removePlugin(name) {
        this.debug(`[Player] Removing plugin: ${name}`);
        return this.pluginManager.unregister(name);
    }
    async connect(channel) {
        try {
            this.debug(`[Player] Connecting to voice channel: ${channel.id}`);
            const connection = (0, voice_1.joinVoiceChannel)({
                channelId: channel.id,
                guildId: channel.guildId,
                adapterCreator: channel.guild.voiceAdapterCreator,
                selfDeaf: this.options.selfDeaf ?? true,
                selfMute: this.options.selfMute ?? false,
            });
            await (0, voice_1.entersState)(connection, voice_1.VoiceConnectionStatus.Ready, 50000);
            this.connection = connection;
            connection.on(voice_1.VoiceConnectionStatus.Disconnected, () => {
                this.debug(`[Player] VoiceConnectionStatus.Disconnected`);
                this.destroy();
            });
            connection.on("error", (error) => {
                this.debug(`[Player] Voice connection error:`, error);
                this.emit("connectionError", error);
            });
            connection.subscribe(this.audioPlayer);
            if (this.leaveTimeout) {
                clearTimeout(this.leaveTimeout);
                this.leaveTimeout = null;
            }
            return this.connection;
        }
        catch (error) {
            this.debug(`[Player] Connection error:`, error);
            this.emit("connectionError", error);
            this.connection?.destroy();
            throw error;
        }
    }
    async search(query, requestedBy) {
        this.debug(`[Player] Search called with query: ${query}, requestedBy: ${requestedBy}`);
        const plugins = this.pluginManager.getAll();
        let lastError = null;
        for (const p of plugins) {
            try {
                this.debug(`[Player] Trying plugin for search: ${p.name}`);
                const res = await this.withTimeout(p.search(query, requestedBy), `Search operation timed out for ${p.name}`);
                if (res && Array.isArray(res.tracks) && res.tracks.length > 0) {
                    this.debug(`[Player] Plugin '${p.name}' returned ${res.tracks.length} tracks`);
                    return res;
                }
                this.debug(`[Player] Plugin '${p.name}' returned no tracks`);
            }
            catch (error) {
                lastError = error;
                this.debug(`[Player] Search via plugin '${p.name}' failed:`, error);
                // Continue to next plugin
            }
        }
        this.debug(`[Player] No plugins returned results for query: ${query}`);
        if (lastError)
            this.emit("playerError", lastError);
        throw new Error(`No plugin found to handle: ${query}`);
    }
    async play(query, requestedBy) {
        try {
            this.debug(`[Player] Play called with query: ${typeof query === "string" ? query : query?.title}`);
            let tracksToAdd = [];
            let isPlaylist = false;
            if (typeof query === "string") {
                const searchResult = await this.search(query, requestedBy || "Unknown");
                tracksToAdd = searchResult.tracks;
                if (searchResult.playlist) {
                    isPlaylist = true;
                    this.debug(`[Player] Added playlist: ${searchResult.playlist.name} (${tracksToAdd.length} tracks)`);
                }
            }
            else {
                tracksToAdd = [query];
            }
            if (tracksToAdd.length === 0) {
                this.debug(`[Player] No tracks found for play`);
                throw new Error("No tracks found");
            }
            // If a TTS track is requested and interrupt mode is enabled, handle it separately
            const isTTS = (t) => {
                if (!t)
                    return false;
                try {
                    return typeof t.source === "string" && t.source.toLowerCase().includes("tts");
                }
                catch {
                    return false;
                }
            };
            const queryLooksTTS = typeof query === "string" && query.trim().toLowerCase().startsWith("tts");
            if (!isPlaylist &&
                tracksToAdd.length > 0 &&
                this.options?.tts?.interrupt !== false &&
                (isTTS(tracksToAdd[0]) || queryLooksTTS)) {
                // Interrupt music playback with TTS (do not modify the music queue)
                this.debug(`[Player] Interrupting with TTS: ${tracksToAdd[0].title}`);
                await this.interruptWithTTSTrack(tracksToAdd[0]);
                return true;
            }
            if (isPlaylist) {
                this.queue.addMultiple(tracksToAdd);
                this.emit("queueAddList", tracksToAdd);
            }
            else {
                this.queue.add(tracksToAdd?.[0]);
                this.emit("queueAdd", tracksToAdd?.[0]);
            }
            // Start playing if not already playing
            if (!this.isPlaying) {
                return this.playNext();
            }
            return true;
        }
        catch (error) {
            this.debug(`[Player] Play error:`, error);
            this.emit("playerError", error);
            return false;
        }
    }
    /**
     * Interrupt current music with a TTS track. Pauses music, swaps the
     * subscription to a dedicated TTS player, plays TTS, then resumes.
     */
    async interruptWithTTSTrack(track) {
        this.ttsQueue.push(track);
        if (!this.ttsActive) {
            void this.playNextTTS();
        }
    }
    /** Play queued TTS items sequentially */
    async playNextTTS() {
        const next = this.ttsQueue.shift();
        if (!next)
            return;
        this.ttsActive = true;
        try {
            if (!this.connection)
                throw new Error("No voice connection for TTS");
            const ttsPlayer = this.ensureTTSPlayer();
            // Build resource from plugin stream
            const resource = await this.resourceFromTrack(next);
            if (resource.volume) {
                resource.volume.setVolume((this.options?.tts?.volume ?? this?.volume ?? 100) / 100);
            }
            const wasPlaying = this.audioPlayer.state.status === voice_1.AudioPlayerStatus.Playing ||
                this.audioPlayer.state.status === voice_1.AudioPlayerStatus.Buffering;
            // Pause current music if any
            try {
                this.audioPlayer.pause(true);
            }
            catch { }
            // Swap subscription and play TTS
            this.connection.subscribe(ttsPlayer);
            this.emit("ttsStart", { track: next });
            ttsPlayer.play(resource);
            // Wait until TTS starts then finishes
            await (0, voice_1.entersState)(ttsPlayer, voice_1.AudioPlayerStatus.Playing, 5000).catch(() => null);
            await (0, voice_1.entersState)(ttsPlayer, voice_1.AudioPlayerStatus.Idle, this.options?.tts?.Max_Time_TTS || 60000).catch(() => null);
            // Swap back and resume if needed
            this.connection.subscribe(this.audioPlayer);
            if (wasPlaying) {
                try {
                    this.audioPlayer.unpause();
                }
                catch { }
            }
            this.emit("ttsEnd");
        }
        catch (err) {
            this.debug("[TTS] error while playing:", err);
            this.emit("playerError", err);
        }
        finally {
            this.ttsActive = false;
            if (this.ttsQueue.length > 0) {
                await this.playNextTTS();
            }
        }
    }
    /** Build AudioResource for a given track using the plugin pipeline */
    async resourceFromTrack(track) {
        // Resolve plugin similar to playNext
        const plugin = this.pluginManager.findPlugin(track.url) || this.pluginManager.get(track.source);
        if (!plugin)
            throw new Error(`No plugin found for track: ${track.title}`);
        let streamInfo;
        try {
            streamInfo = await this.withTimeout(plugin.getStream(track), "getStream timed out");
        }
        catch (streamError) {
            // try fallbacks
            const allplugs = this.pluginManager.getAll();
            for (const p of allplugs) {
                if (typeof p.getFallback !== "function")
                    continue;
                try {
                    streamInfo = await this.withTimeout(p.getFallback(track), `getFallback timed out for plugin ${p.name}`);
                    if (!streamInfo?.stream)
                        continue;
                    break;
                }
                catch { }
            }
            if (!streamInfo?.stream)
                throw new Error(`All getFallback attempts failed for track: ${track.title}`);
        }
        const mapToStreamType = (type) => {
            switch (type) {
                case "webm/opus":
                    return voice_1.StreamType.WebmOpus;
                case "ogg/opus":
                    return voice_1.StreamType.OggOpus;
                case "arbitrary":
                default:
                    return voice_1.StreamType.Arbitrary;
            }
        };
        const inputType = mapToStreamType(streamInfo.type);
        return (0, voice_1.createAudioResource)(streamInfo.stream, {
            metadata: track,
            inputType,
            inlineVolume: true,
        });
    }
    async generateWillNext() {
        const lastTrack = this.queue.previousTracks[this.queue.previousTracks.length - 1] ?? this.queue.currentTrack;
        if (!lastTrack)
            return;
        // Build list of candidate plugins: preferred first, then others with getRelatedTracks
        const preferred = this.pluginManager.findPlugin(lastTrack.url) || this.pluginManager.get(lastTrack.source);
        const all = this.pluginManager.getAll();
        const candidates = [...(preferred ? [preferred] : []), ...all.filter((p) => p !== preferred)].filter((p) => typeof p.getRelatedTracks === "function");
        for (const p of candidates) {
            try {
                this.debug(`[Player] Trying related from plugin: ${p.name}`);
                const related = await this.withTimeout(p.getRelatedTracks(lastTrack.url, {
                    limit: 10,
                    history: this.queue.previousTracks,
                }), `getRelatedTracks timed out for ${p.name}`);
                if (Array.isArray(related) && related.length > 0) {
                    const randomchoice = Math.floor(Math.random() * related.length);
                    const nextTrack = this.queue.nextTrack ? this.queue.nextTrack : related[randomchoice];
                    this.queue.willNextTrack(nextTrack);
                    this.debug(`[Player] Will next track if autoplay: ${nextTrack?.title} (via ${p.name})`);
                    this.emit("willPlay", nextTrack, related);
                    return; // success
                }
                this.debug(`[Player] ${p.name} returned no related tracks`);
            }
            catch (err) {
                this.debug(`[Player] getRelatedTracks error from ${p.name}:`, err);
                // try next candidate
            }
        }
    }
    async playNext() {
        this.debug(`[Player] playNext called`);
        const track = this.queue.next(this.skipLoop);
        this.skipLoop = false;
        if (!track) {
            if (this.queue.autoPlay()) {
                const willnext = this.queue.willNextTrack();
                console.log("willnext", willnext);
                if (willnext) {
                    this.debug(`[Player] Auto-playing next track: ${willnext.title}`);
                    this.queue.addMultiple([willnext]);
                    return this.playNext();
                }
            }
            this.debug(`[Player] No next track in queue`);
            this.isPlaying = false;
            this.emit("queueEnd");
            if (this.options.leaveOnEnd) {
                this.scheduleLeave();
            }
            return false;
        }
        this.generateWillNext();
        try {
            // Find plugin that can handle this track
            const plugin = this.pluginManager.findPlugin(track.url) || this.pluginManager.get(track.source);
            if (!plugin) {
                this.debug(`[Player] No plugin found for track: ${track.title}`);
                throw new Error(`No plugin found for track: ${track.title}`);
            }
            this.debug(`[Player] Getting stream for track: ${track.title}`);
            this.debug(`[Player] Using plugin: ${plugin.name}`);
            this.debug(`[Track] Track Info:`, track);
            let streamInfo;
            try {
                streamInfo = await this.withTimeout(plugin.getStream(track), "getStream timed out");
            }
            catch (streamError) {
                this.debug(`[Player] getStream failed, trying getFallback:`, streamError);
                const allplugs = this.pluginManager.getAll();
                for (const p of allplugs) {
                    if (typeof p.getFallback !== "function") {
                        continue;
                    }
                    try {
                        streamInfo = await this.withTimeout(p.getFallback(track), `getFallback timed out for plugin ${p.name}`);
                        if (!streamInfo.stream)
                            continue;
                        this.debug(`[Player] getFallback succeeded with plugin ${p.name} for track: ${track.title}`);
                        break;
                    }
                    catch (fallbackError) {
                        this.debug(`[Player] getFallback failed with plugin ${p.name}:`, fallbackError);
                    }
                }
                if (!streamInfo?.stream) {
                    throw new Error(`All getFallback attempts failed for track: ${track.title}`);
                }
                this.debug(streamInfo);
            }
            function mapToStreamType(type) {
                switch (type) {
                    case "webm/opus":
                        return voice_1.StreamType.WebmOpus;
                    case "ogg/opus":
                        return voice_1.StreamType.OggOpus;
                    case "arbitrary":
                        return voice_1.StreamType.Arbitrary;
                    default:
                        return voice_1.StreamType.Arbitrary;
                }
            }
            let stream = streamInfo.stream;
            let inputType = mapToStreamType(streamInfo.type);
            this.currentResource = (0, voice_1.createAudioResource)(stream, {
                metadata: track,
                inputType,
                inlineVolume: true,
            });
            // Apply initial volume using the resource's VolumeTransformer
            if (this.volumeInterval) {
                clearInterval(this.volumeInterval);
                this.volumeInterval = null;
            }
            this.currentResource.volume?.setVolume(this.volume / 100);
            this.debug(`[Player] Playing resource for track: ${track.title}`);
            this.audioPlayer.play(this.currentResource);
            await (0, voice_1.entersState)(this.audioPlayer, voice_1.AudioPlayerStatus.Playing, 5000);
            return true;
        }
        catch (error) {
            this.debug(`[Player] playNext error:`, error);
            this.emit("playerError", error, track);
            return this.playNext();
        }
    }
    pause() {
        this.debug(`[Player] pause called`);
        if (this.isPlaying && !this.isPaused) {
            return this.audioPlayer.pause();
        }
        return false;
    }
    resume() {
        this.debug(`[Player] resume called`);
        if (this.isPaused) {
            const result = this.audioPlayer.unpause();
            if (result) {
                const track = this.queue.currentTrack;
                if (track) {
                    this.debug(`[Player] Player resumed on track: ${track.title}`);
                    this.emit("playerResume", track);
                }
            }
            return result;
        }
        return false;
    }
    stop() {
        this.debug(`[Player] stop called`);
        this.queue.clear();
        const result = this.audioPlayer.stop();
        this.isPlaying = false;
        this.isPaused = false;
        this.emit("playerStop");
        return result;
    }
    skip() {
        this.debug(`[Player] skip called`);
        if (this.isPlaying || this.isPaused) {
            this.skipLoop = true;
            return this.audioPlayer.stop();
        }
        return !!this.playNext();
    }
    loop(mode) {
        return this.queue.loop(mode);
    }
    autoPlay(mode) {
        return this.queue.autoPlay(mode);
    }
    setVolume(volume) {
        this.debug(`[Player] setVolume called: ${volume}`);
        if (volume < 0 || volume > 200)
            return false;
        const oldVolume = this.volume;
        this.volume = volume;
        const resourceVolume = this.currentResource?.volume;
        if (resourceVolume) {
            if (this.volumeInterval)
                clearInterval(this.volumeInterval);
            const start = resourceVolume.volume;
            const target = this.volume / 100;
            const steps = 10;
            let currentStep = 0;
            this.volumeInterval = setInterval(() => {
                currentStep++;
                const value = start + ((target - start) * currentStep) / steps;
                resourceVolume.setVolume(value);
                if (currentStep >= steps) {
                    clearInterval(this.volumeInterval);
                    this.volumeInterval = null;
                }
            }, 300);
        }
        this.emit("volumeChange", oldVolume, volume);
        return true;
    }
    shuffle() {
        this.debug(`[Player] shuffle called`);
        this.queue.shuffle();
    }
    clearQueue() {
        this.debug(`[Player] clearQueue called`);
        this.queue.clear();
    }
    /**
     * Insert a track or list of tracks into the upcoming queue at a specific position (0 = play after current).
     * - If `query` is a string, performs a search and inserts resulting tracks (playlist supported).
     * - If a Track or Track[] is provided, inserts directly.
     * Does not auto-start playback; it only modifies the queue.
     */
    async insert(query, index, requestedBy) {
        try {
            this.debug(`[Player] insert called at index ${index} with type: ${typeof query}`);
            let tracksToAdd = [];
            let isPlaylist = false;
            if (typeof query === "string") {
                const searchResult = await this.search(query, requestedBy || "Unknown");
                tracksToAdd = searchResult.tracks || [];
                isPlaylist = !!searchResult.playlist;
            }
            else if (Array.isArray(query)) {
                tracksToAdd = query;
                isPlaylist = query.length > 1;
            }
            else if (query) {
                tracksToAdd = [query];
            }
            if (!tracksToAdd || tracksToAdd.length === 0) {
                this.debug(`[Player] insert: no tracks resolved`);
                throw new Error("No tracks to insert");
            }
            if (tracksToAdd.length === 1) {
                this.queue.insert(tracksToAdd[0], index);
                this.emit("queueAdd", tracksToAdd[0]);
                this.debug(`[Player] Inserted track at index ${index}: ${tracksToAdd[0].title}`);
            }
            else {
                this.queue.insertMultiple(tracksToAdd, index);
                this.emit("queueAddList", tracksToAdd);
                this.debug(`[Player] Inserted ${tracksToAdd.length} ${isPlaylist ? "playlist " : ""}tracks at index ${index}`);
            }
            return true;
        }
        catch (error) {
            this.debug(`[Player] insert error:`, error);
            this.emit("playerError", error);
            return false;
        }
    }
    remove(index) {
        this.debug(`[Player] remove called for index: ${index}`);
        const track = this.queue.remove(index);
        if (track) {
            this.emit("queueRemove", track, index);
        }
        return track;
    }
    getProgressBar(options = {}) {
        const { size = 20, barChar = "â–¬", progressChar = "ðŸ”˜" } = options;
        const track = this.queue.currentTrack;
        const resource = this.currentResource;
        if (!track || !resource)
            return "";
        const total = track.duration > 1000 ? track.duration : track.duration * 1000;
        if (!total)
            return this.formatTime(resource.playbackDuration);
        const current = resource.playbackDuration;
        const ratio = Math.min(current / total, 1);
        const progress = Math.round(ratio * size);
        const bar = barChar.repeat(progress) + progressChar + barChar.repeat(size - progress);
        return `${this.formatTime(current)} ${bar} ${this.formatTime(total)}`;
    }
    formatTime(ms) {
        const totalSeconds = Math.floor(ms / 1000);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;
        const parts = [];
        if (hours > 0)
            parts.push(String(hours).padStart(2, "0"));
        parts.push(String(minutes).padStart(2, "0"));
        parts.push(String(seconds).padStart(2, "0"));
        return parts.join(":");
    }
    scheduleLeave() {
        this.debug(`[Player] scheduleLeave called`);
        if (this.leaveTimeout) {
            clearTimeout(this.leaveTimeout);
        }
        if (this.options.leaveOnEmpty && this.options.leaveTimeout) {
            this.leaveTimeout = setTimeout(() => {
                this.debug(`[Player] Leaving voice channel after timeout`);
                this.destroy();
            }, this.options.leaveTimeout);
        }
    }
    destroy() {
        this.debug(`[Player] destroy called`);
        if (this.leaveTimeout) {
            clearTimeout(this.leaveTimeout);
            this.leaveTimeout = null;
        }
        this.audioPlayer.stop(true);
        if (this.ttsPlayer) {
            try {
                this.ttsPlayer.stop(true);
            }
            catch { }
            this.ttsPlayer = null;
        }
        if (this.connection) {
            this.connection.destroy();
            this.connection = null;
        }
        this.queue.clear();
        this.pluginManager.clear();
        this.isPlaying = false;
        this.isPaused = false;
        this.emit("playerDestroy");
        this.removeAllListeners();
    }
    // Getters
    get queueSize() {
        return this.queue.size;
    }
    get currentTrack() {
        return this.queue.currentTrack;
    }
    get upcomingTracks() {
        return this.queue.getTracks();
    }
    get previousTracks() {
        return this.queue.previousTracks;
    }
    get availablePlugins() {
        return this.pluginManager.getAll().map((p) => p.name);
    }
}
exports.Player = Player;
//# sourceMappingURL=Player.js.map