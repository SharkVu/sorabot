"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TTSPlugin = void 0;
const ziplayer_1 = require("ziplayer");
const stream_1 = require("stream");
const zitts_1 = require("@zibot/zitts");
const axios_1 = __importDefault(require("axios"));
class TTSPlugin extends ziplayer_1.BasePlugin {
    constructor(opts) {
        super();
        this.name = "tts";
        this.version = "1.0.0";
        this.opts = {
            defaultLang: opts?.defaultLang || "vi",
            slow: !!opts?.slow,
        };
    }
    canHandle(query) {
        if (!query)
            return false;
        const q = query.trim().toLowerCase();
        return q.startsWith("tts:") || q.startsWith("say ");
    }
    async search(query, requestedBy) {
        const { text, lang, slow } = this.parseQuery(query);
        const config = { text, lang, slow };
        const url = this.encodeConfig(config);
        const title = `TTS (${lang}${slow ? ", slow" : ""}): ${text.slice(0, 64)}${text.length > 64 ? "â€¦" : ""}`;
        const estimatedSeconds = Math.max(1, Math.min(60, Math.ceil(text.length / 12)));
        const track = {
            id: `tts-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
            title,
            url,
            duration: estimatedSeconds,
            requestedBy,
            source: this.name,
            metadata: { tts: config },
        };
        return { tracks: [track] };
    }
    async getStream(track) {
        const cfg = this.extractConfig(track);
        const urls = (0, zitts_1.getTTSUrls)(cfg.text, { lang: cfg.lang, slow: cfg.slow });
        if (!urls || urls.length === 0) {
            throw new Error("TTS returned no audio URLs");
        }
        const parts = await Promise.all(urls.map((u) => axios_1.default.get(u, { responseType: "arraybuffer" }).then((r) => Buffer.from(r.data))));
        const merged = Buffer.concat(parts);
        const stream = stream_1.Readable.from([merged]);
        return { stream, type: "arbitrary", metadata: { size: merged.length } };
    }
    parseQuery(query) {
        const raw = query.trim();
        let text = raw;
        let lang = this.opts.defaultLang;
        let slow = this.opts.slow;
        if (raw.toLowerCase().startsWith("say ")) {
            text = raw.slice(4).trim();
        }
        else if (raw.toLowerCase().startsWith("tts:")) {
            const body = raw.slice(4).trim();
            // Formats supported:
            // - "tts: <text>"
            // - "tts:vi:<text>"
            // - "tts:vi:1:<text>"  (1 => slow, 0 => normal)
            const parts = body.split(":");
            if (parts.length >= 1) {
                if (parts.length === 1) {
                    text = parts[0].trim();
                }
                else if (parts.length === 2) {
                    lang = (parts[0] || lang).trim() || lang;
                    text = parts[1].trim();
                }
                else {
                    lang = (parts[0] || lang).trim() || lang;
                    const slowFlag = (parts[1] || "0").trim();
                    slow = slowFlag === "1" || slowFlag.toLowerCase() === "true";
                    text = parts.slice(2).join(":").trim();
                }
            }
        }
        if (!text)
            throw new Error("No text provided for TTS");
        return { text, lang, slow };
    }
    encodeConfig(cfg) {
        const payload = encodeURIComponent(JSON.stringify(cfg));
        return `tts://${payload}`;
    }
    extractConfig(track) {
        const meta = track.metadata?.tts;
        if (meta && meta.text)
            return meta;
        try {
            const url = track.url || "";
            const encoded = url.startsWith("tts://") ? url.slice("tts://".length) : url;
            const cfg = JSON.parse(decodeURIComponent(encoded));
            return { text: cfg.text, lang: cfg.lang || this.opts.defaultLang, slow: !!cfg.slow };
        }
        catch {
            return { text: track.title || "", lang: this.opts.defaultLang, slow: this.opts.slow };
        }
    }
}
exports.TTSPlugin = TTSPlugin;
//# sourceMappingURL=ttsPlugin.js.map