"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TTSPlugin = void 0;
const ziplayer_1 = require("ziplayer");
const stream_1 = require("stream");
const zitts_1 = require("@zibot/zitts");
const axios_1 = __importDefault(require("axios"));
class TTSPlugin extends ziplayer_1.BasePlugin {
    constructor(opts) {
        super();
        this.name = "tts";
        this.version = "1.0.0";
        this.opts = {
            defaultLang: opts?.defaultLang || "vi",
            slow: !!opts?.slow,
            createStream: opts?.createStream,
        };
    }
    canHandle(query) {
        if (!query)
            return false;
        const q = query.trim().toLowerCase();
        return q.startsWith("tts:") || q.startsWith("say ");
    }
    async search(query, requestedBy) {
        if (!this.canHandle(query)) {
            return { tracks: [] };
        }
        const { text, lang, slow } = this.parseQuery(query);
        const config = { text, lang, slow };
        const url = this.encodeConfig(config);
        const title = `TTS (${lang}${slow ? ", slow" : ""}): ${text.slice(0, 64)}${text.length > 64 ? "â€¦" : ""}`;
        const estimatedSeconds = Math.max(1, Math.min(60, Math.ceil(text.length / 12)));
        const track = {
            id: `tts-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
            title,
            url,
            duration: estimatedSeconds,
            requestedBy,
            source: this.name,
            metadata: { tts: config },
        };
        return { tracks: [track] };
    }
    async getStream(track) {
        const cfg = this.extractConfig(track);
        if (this.opts.createStream && typeof this.opts.createStream === "function") {
            const out = await this.opts.createStream(cfg.text, { lang: cfg.lang, slow: cfg.slow, track });
            let type;
            let metadata;
            let stream = null;
            const normType = (t) => {
                if (!t || typeof t !== "string")
                    return undefined;
                const v = t.toLowerCase();
                if (v.includes("webm") && v.includes("opus"))
                    return "webm/opus";
                if (v.includes("ogg") && v.includes("opus"))
                    return "ogg/opus";
                return undefined;
            };
            if (out && typeof out === "object") {
                // If it's already a Readable/Buffer/Uint8Array/ArrayBuffer/URL, let toReadable handle it
                if (out instanceof stream_1.Readable ||
                    out instanceof Buffer ||
                    out instanceof Uint8Array ||
                    out instanceof ArrayBuffer ||
                    out instanceof URL) {
                    stream = await this.toReadable(out);
                }
                else if (out.stream) {
                    const o = out;
                    stream = o.stream;
                    type = normType(o.type);
                    metadata = o.metadata;
                }
                else if (out.url) {
                    const o = out;
                    const urlStr = o.url.toString();
                    try {
                        type =
                            normType(o.type) ||
                                (urlStr.endsWith(".webm") ? "webm/opus"
                                    : urlStr.endsWith(".ogg") ? "ogg/opus"
                                        : undefined);
                        const res = await axios_1.default.get(urlStr, { responseType: "stream" });
                        stream = res.data;
                        metadata = o.metadata;
                    }
                    catch (e) {
                        throw new Error(`Failed to fetch custom TTS URL: ${e}`);
                    }
                }
            }
            if (!stream) {
                stream = await this.toReadable(out);
            }
            return { stream, type: type || "arbitrary", metadata: { provider: "custom", ...(metadata || {}) } };
        }
        const urls = (0, zitts_1.getTTSUrls)(cfg.text, { lang: cfg.lang, slow: cfg.slow });
        if (!urls || urls.length === 0) {
            throw new Error("TTS returned no audio URLs");
        }
        const parts = await Promise.all(urls.map((u) => axios_1.default.get(u, { responseType: "arraybuffer" }).then((r) => Buffer.from(r.data))));
        const merged = Buffer.concat(parts);
        const stream = stream_1.Readable.from([merged]);
        return { stream, type: "arbitrary", metadata: { size: merged.length } };
    }
    async toReadable(out) {
        if (out instanceof stream_1.Readable)
            return out;
        if (typeof out === "string" || out instanceof URL) {
            const url = out instanceof URL ? out.toString() : out;
            if (/^https?:\/\//i.test(url)) {
                const res = await axios_1.default.get(url, { responseType: "stream" });
                return res.data;
            }
            return stream_1.Readable.from([Buffer.from(url)]);
        }
        if (out instanceof Buffer)
            return stream_1.Readable.from([out]);
        if (out instanceof Uint8Array)
            return stream_1.Readable.from([Buffer.from(out)]);
        if (out instanceof ArrayBuffer)
            return stream_1.Readable.from([Buffer.from(out)]);
        throw new Error("Unsupported return type from createStream");
    }
    parseQuery(query) {
        const isLangCode = (s) => /^[a-z]{2,3}(?:-[A-Z]{2})?$/.test(s);
        const raw = query.trim();
        let text = raw;
        let lang = this.opts.defaultLang;
        let slow = this.opts.slow;
        const lower = raw.toLowerCase();
        if (lower.startsWith("say ")) {
            text = raw.slice(4).trim();
        }
        else if (lower.startsWith("tts:")) {
            const body = raw.slice(4).trim();
            // Supported:
            // - "tts: <text>" (text may contain colons)
            // - "tts:<lang>:<text>"
            // - "tts:<lang>:<slow>:<text>" where slow in {0,1,true,false}
            const firstSep = body.indexOf(":");
            if (firstSep === -1) {
                text = body;
            }
            else {
                const maybeLang = body.slice(0, firstSep).trim();
                const rest = body.slice(firstSep + 1).trim();
                if (isLangCode(maybeLang)) {
                    lang = maybeLang;
                    const secondSep = rest.indexOf(":");
                    if (secondSep !== -1) {
                        const maybeSlow = rest.slice(0, secondSep).trim().toLowerCase();
                        const remaining = rest.slice(secondSep + 1).trim();
                        if (["0", "1", "true", "false"].includes(maybeSlow)) {
                            slow = maybeSlow === "1" || maybeSlow === "true";
                            text = remaining;
                        }
                        else {
                            text = rest;
                        }
                    }
                    else {
                        text = rest;
                    }
                }
                else {
                    text = body;
                }
            }
        }
        text = (text || "").trim();
        if (!text)
            throw new Error("No text provided for TTS");
        return { text, lang, slow };
    }
    encodeConfig(cfg) {
        const payload = encodeURIComponent(JSON.stringify(cfg));
        return `tts://${payload}`;
    }
    extractConfig(track) {
        const meta = track.metadata?.tts;
        if (meta && meta.text)
            return meta;
        try {
            const url = track.url || "";
            const encoded = url.startsWith("tts://") ? url.slice("tts://".length) : url;
            const cfg = JSON.parse(decodeURIComponent(encoded));
            return { text: cfg.text, lang: cfg.lang || this.opts.defaultLang, slow: !!cfg.slow };
        }
        catch {
            return { text: track.title || "", lang: this.opts.defaultLang, slow: this.opts.slow };
        }
    }
}
exports.TTSPlugin = TTSPlugin;
//# sourceMappingURL=TTSPlugin.js.map